{
  "currentID": 47,
  "lastUpdate": "2017-10-31T12:03:12.026Z",
  "items": [
    {
      "title": "Sorting algorithm",
      "author": "Mamin Kotik",
      "image_path": "0.jpg",
      "author_link": "TGIfr",
      "date": "2017-10-04T19:37:09.891Z",
      "tags": [
        "sorting",
        "algorithms",
        "basic",
        "quick",
        "beginner"
      ],
      "difficult": 5,
      "description": "Sorting algorithms description , and how to use them",
      "text": [
        "Computational complexity (worst, average and best behavior) in terms of the size of the list (n). For typical serial sorting algorithms good behavior is O(n log n), with parallel sort in O(log2 n), and bad behavior is O(n2). (See Big O notation.) Ideal behavior for a serial sort is O(n), but this is not possible in the average case. Optimal parallel sorting is O(log n). Comparison-based sorting algorithms need at least O(n log n) comparisons for most inputs.",
        "When sorting some kinds of data, only part of the data is examined when determining the sort order. For example, in the card sorting example to the right, the cards are being sorted by their rank, and their suit is being ignored. This allows the possibility of multiple different correctly sorted versions of the original list. Stable sorting algorithms choose one of these, according to the following rule: if two items compare as equal, like the two 5 cards, then their relative order will be preserved, so that if one came before the other in the input, it will also come before the other in the output.",
        "More formally, the data being sorted can be represented as a record or tuple of values, and the part of the data that is used for sorting is called the key. In the card example, cards are represented as a record (rank, suit), and the key is the rank. A sorting algorithm is stable if whenever there are two records R and S with the same key, and R appears before S in the original list, then R will always appear before S in the sorted list.",
        "One application for stable sorting algorithms is sorting a list using a primary and secondary key. For example, suppose we wish to sort a hand of cards such that the suits are in the order clubs (♣), diamonds (♦), hearts (♥), spades (♠), and within each suit, the cards are sorted by rank."
      ],
      "id": 0
    },
    {
      "title": "name",
      "author": "Papin Kotik",
      "image_path": "1.jpg",
      "author_link": "Firefly114",
      "date": "2017-10-04T19:38:42.125Z",
      "tags": [
        "basic",
        "search",
        "linear",
        "expotencial",
        "array"
      ],
      "difficult": 2,
      "description": " Searching algorithms description, and how to use them",
      "text": [
        "The simplest, most general, and least efficient search structure is merely an unordered sequential list of all the items. Locating the desired item in such a list, by the linear search method, inevitably requires a number of operations proportional to the number n of items, in the worst case as well as in the average case. Useful search data structures allow faster retrieval; however, they are limited to queries of some specific kind. Moreover, since the cost of building such structures is at least proportional to n, they only pay off if several queries are to be performed on the same database (or on a database that changes little between queries).",
        "The simplest kind of query is to locate a record that has a specific field (the key) equal to a specified value v. Other common kinds of query are \"find the item with smallest (or largest) key value\", \"find the item with largest key value not exceeding v\", \"find all items with key values between specified bounds vmin and vmax\".",
        "In certain databases the key values may be points in some multi-dimensional space. For example, the key may be a geographic position (latitude and longitude) on the Earth. In that case, common kinds of queries are find the record with a key closest to a given point v\", or \"find all items whose key lies at a given distance from v\", or \"find all items within a specified region R of the space\".",
        "A common special case of the latter are simultaneous range queries on two or more simple keys, such as \"find all employee records with salary between 50,000 and 100,000 and hired between 1995 and 2007\"."
      ],
      "id": 1
    },
    {
      "title": "If-else",
      "author": "My Kotik",
      "description": "If-else construction and more effective using of them",
      "image_path": "2.jpg",
      "author_link": "ElenaKarpenko",
      "date": "2017-10-04T19:51:45.804Z",
      "tags": [
        "basic",
        "language",
        "construction",
        "programming",
        "split"
      ],
      "difficult": 5,
      "text": [
        "The if statement executes a statement if a specified condition is truthy. If the condition is falsy, another statement can be executed. if (condition) statement1 [else statement2]",
        "An expression that is considered to be either truthy or falsy. statement1 Statement that is executed if condition is truthy. Can be any statement, including further nested if statements. To execute multiple statements, use a block statement ({ ... }) to group those statements, to execute no statements, use an empty statement. statement2 Statement that is executed if condition is falsy and the else clause exists. Can be any statement, including block statements and further nested if statements.",
        "if (condition1) statement1 else if (condition2) statement2 else if (condition3) statement3 ... else statementN",
        "Do not confuse the primitive boolean values true and false with truthiness or falsiness of the Boolean object. Any value that is not undefined, null, 0, NaN, or the empty string (\"\"), and any object, including a Boolean object whose value is false, is considered truthy when used as the condition. For example:",
        "Note that there is no elseif syntax in JavaScript. However, you can write it with a space between else and if: if (x > 5) { /* do the right thing */ } else if (x > 50) { /* do the right thing */ } else { /* do the right thing */ }",
        "Assignment within the conditional expression It is advisable to not use simple assignments in a conditional expression, because the assignment can be confused with equality when glancing over the code. For example, do not use the following code: if (x = y) { /* do the right thing */ } If you need to use an assignment in a conditional expression, a common practice is to put additional parentheses around the assignment. For example: if ((x = y)) { /* do the right thing */ }"
      ],
      "id": 2
    },
    {
      "title": "OOP",
      "author": "And one more Kotik",
      "description": "Object oriented programing description and explain how to use it",
      "image_path": "3.jpg",
      "author_link": "NadineCh",
      "date": "2017-10-04T19:54:18.540Z",
      "tags": [
        "paradigm",
        "intermediate",
        "objects",
        "class",
        "oop"
      ],
      "difficult": 7,
      "text": [
        "Object-oriented programming (OOP) is a programming paradigm based on the concept of \"objects\", which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of \"this\" or \"self\"). In OOP, computer programs are designed by making them out of objects that interact with one another.[1][2] There is significant diversity of OOP languages, but the most popular ones are class-based, meaning that objects are instances of classes, which typically also determine their type.",
        "Many of the most widely used programming languages (such as C++, Object Pascal, Java, Python etc.) are multi-paradigm programming languages that support object-oriented programming to a greater or lesser degree, typically in combination with imperative, procedural programming. Significant object-oriented languages include Java, C++, C#, Python, PHP, Ruby, Perl, Object Pascal, Objective-C, Dart, Swift, Scala, Common Lisp, and Smalltalk.",
        "Variables that can store information formatted in a small number of built-in data types like integers and alphanumeric characters. This may include data structures like strings, lists, and hash tables that are either built-in or result from combining variables using memory pointers Procedures – also known as functions, methods, routines, or subroutines – that take input, generate output, and manipulate data. Modern languages include structured programming constructs like loops and conditionals. Modular programming support provides the ability to group procedures into files and modules for organizational purposes. Modules are namespaced so code in one module will not be accidentally confused with the same procedure or variable name in another file or module.",
        "Do not confuse the primitive boolean values true and false with truthiness or falsiness of the Boolean object. Any value that is not undefined, null, 0, NaN, or the empty string (\"\"), and any object, including a Boolean object whose value is false, is considered truthy when used as the condition. For example:",
        "Languages that support object-oriented programming typically use inheritance for code reuse and extensibility in the form of either classes or prototypes. Those that use classes support two main concepts: Classes – the definitions for the data format and available procedures for a given type or class of object; may also contain data and procedures (known as class methods) themselves, i.e. classes contain the data members and member functions Objects – instances of classes Objects sometimes correspond to things found in the real world. For example, a graphics program may have objects such as \"circle\", \"square\", \"menu\". An online shopping system might have objects such as \"shopping cart\", \"customer\", and \"product\".[7] Sometimes objects represent more abstract entities, like an object that represents an open file, or an object that provides the service of translating measurements from U.S. customary to metric.",
        "Class variables – belong to the class as a whole; there is only one copy of each one Instance variables or attributes – data that belongs to individual objects; every object has its own copy of each one Member variables – refers to both the class and instance variables that are defined by a particular class Class methods – belong to the class as a whole and have access only to class variables and inputs from the procedure call Instance methods – belong to individual objects, and have access to instance variables for the specific object they are called on, inputs, and class variables Objects are accessed somewhat like variables with complex internal structure, and in many languages are effectively pointers, serving as actual references to a single instance of said object in memory within a heap or stack. They provide a layer of abstraction which can be used to separate internal from external code. Externa"
      ],
      "id": 3
    },
    {
      "title": "History of programming",
      "author": "The main Kotik",
      "description": "Short history of programming and it's design",
      "image_path": "4.jpg",
      "author_link": "rulline",
      "date": "2017-10-04T19:57:11.306Z",
      "tags": [
        "history",
        "programming",
        "start",
        "all"
      ],
      "difficult": 1,
      "text": [
        "In the 1940s, the first recognizably modern electrically powered computers were created. The limited speed and memory capacity forced programmers to write hand tuned assembly language programs. It was eventually realized that programming in assembly language required a great deal of intellectual effort. The first programming languages designed to communicate instructions to a computer were written in the 1950s. An early high-level programming language to be designed for a computer was Plankalkül, developed by the Germans for Z1 by Konrad Zuse between 1943 and 1945. However, it was not implemented until 1998 and 2000.",
        "John Mauchly's Short Code, proposed in 1949, was one of the first high-level languages ever developed for an electronic computer.[3] Unlike machine code, Short Code statements represented mathematical expressions in understandable form. However, the program had to be translated into machine code every time it ran, making the process much slower than running the equivalent machine code. At the University of Manchester, Alick Glennie developed Autocode in the early 1950s. A programming language, it used a compiler to automatically convert the language into machine code. The first code and compiler was developed in 1952 for the Mark 1 computer at the University of Manchester and is considered to be the first compiled high-level programming language.",
        "The second autocode was developed for the Mark 1 by R. A. Brooker in 1954 and was called the \"Mark 1 Autocode\". Brooker also developed an autocode for the Ferranti Mercury in the 1950s in conjunction with the University of Manchester. The version for the EDSAC 2 was devised by D. F. Hartley of University of Cambridge Mathematical Laboratory in 1961. Known as EDSAC 2 Autocode, it was a straight development from Mercury Autocode adapted for local circumstances, and was noted for its object code optimisation and source-language diagnostics which were advanced for the time. A contemporary but separate thread of development, Atlas Autocode was developed for the University of Manchester Atlas 1 machine. In 1954, language FORTRAN was invented at IBM by John Backus; it was the first widely used high level general purpose programming language to have a functional implementation, as opposed to just a design on paper.[6][7] It is still a popular language for high-performance computing[8] and is used for programs that benchmark and rank the world's fastest supercomputers.",
        "Algol's key ideas were continued, producing ALGOL 68: syntax and semantics became even more orthogonal, with anonymous routines, a recursive typing system with higher-order functions, etc.; not only the context-free part, but the full language syntax and semantics were defined formally, in terms of Van Wijngaarden grammar, a formalism designed specifically for this purpose. Algol 68's many little-used language features (for example, concurrent and parallel blocks) and its complex system of syntactic shortcuts and automatic type coercions made it unpopular with implementers and gained it a reputation of being difficult. Niklaus Wirth actually walked out of the design committee to create the simpler Pascal language."
      ],
      "id": 4
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "q",
      "image_path": "BkzrxXrAW.jpg",
      "author_link": "ZulusK",
      "date": "2017-10-30T21:57:14.455Z",
      "tags": [
        "tag"
      ],
      "difficult": "1",
      "text": "dfg",
      "id": 45
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "q",
      "image_path": "SyoxxK4RZ.jpg",
      "author_link": "ZulusK",
      "date": "2017-10-30T10:33:23.223Z",
      "tags": [
        "tag",
        "3"
      ],
      "difficult": "1",
      "text": "                    some text\r\n                ",
      "id": 41
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "q",
      "image_path": "By3l6dVC-.jpg",
      "author_link": "ZulusK",
      "date": "2017-10-30T10:20:36.173Z",
      "tags": [
        "tag1"
      ],
      "difficult": "1",
      "text": "                    some text\r\n                ",
      "id": 34
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "q",
      "image_path": "rJxuTd4RZ.jpg",
      "author_link": "ZulusK",
      "date": "2017-10-30T10:22:31.675Z",
      "tags": [
        "tag1"
      ],
      "difficult": "1",
      "text": "                    some text\r\n                ",
      "id": 35
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "q",
      "image_path": "",
      "author_link": "ZulusK",
      "date": "2017-10-30T10:26:21.301Z",
      "tags": [
        "tag1"
      ],
      "difficult": "1",
      "text": "                    some text\r\n                ",
      "id": 36
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "7",
      "image_path": "",
      "author_link": "ZulusK",
      "date": "2017-10-30T10:27:55.050Z",
      "tags": [
        "tag1"
      ],
      "difficult": "1",
      "text": "                    some text\r\n                ",
      "id": 37
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "q",
      "image_path": "HyFJyFVCZ.jpg",
      "author_link": "ZulusK",
      "date": "2017-10-30T10:28:49.117Z",
      "tags": [
        "tag1"
      ],
      "difficult": "1",
      "text": "                    some text\r\n                ",
      "id": 38
    },
    {
      "title": "A",
      "author": "Danil",
      "description": "q",
      "image_path": "rJNN7nV0W.jpg",
      "author_link": "ZulusK",
      "date": "2017-10-30T14:11:56.033Z",
      "tags": [
        "tag",
        "tag1"
      ],
      "difficult": "1",
      "text": "qwsedftgy",
      "id": 44
    },
    {
      "title": "B",
      "author": "Danil",
      "description": "q",
      "image_path": "BJOYIkLAZ.jpg",
      "author_link": "ZulusK",
      "date": "2017-10-31T12:03:12.011Z",
      "tags": [
        "tag"
      ],
      "difficult": "1",
      "text": "sdefg",
      "id": 46
    }
  ]
}